<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dorna Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#444; }
  </style>

  <!-- Three.js & helpers -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
  <script>
    // --- Scene (Z-up, millimeters) ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x444444); // slightly lighter gray

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100000);
    camera.up.set(0, 0, 1);                 // Z-up
    camera.position.set(1600, 600, 800);    // in mm

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = false;
    controls.target.set(0, 0, 0);
    controls.minDistance = 5;
    controls.maxDistance = 50000;
    controls.zoomSpeed = 1.2;

    // --- Helpers for labels ---
    function makeTextSprite(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pad = 16;
      ctx.font = 'bold 48px system-ui, Arial';
      const m = ctx.measureText(text);
      canvas.width  = Math.max(64, Math.ceil(m.width + pad * 2));
      canvas.height = 72 + pad * 2;
      const c2 = canvas.getContext('2d');
      c2.font = 'bold 48px system-ui, Arial';
      c2.textBaseline = 'middle'; c2.textAlign = 'center';
      c2.lineWidth = 6; c2.strokeStyle = 'black';
      c2.strokeText(text, canvas.width/2, canvas.height/2);
      c2.fillStyle = 'white';
      c2.fillText(text, canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
      const s = 60; // sprite size in mm
      spr.scale.set((canvas.width/canvas.height)*s, s, 1);
      return spr;
    }

    // --- World grid 3000 x 1000 mm ---
    const worldWidth = 3000;
    const worldHeight = 1000;
    const gridStep = 50;
    const majorEvery = 500;

    function makeRectGrid(width, height, step, major, colorMinor = 0x555555, colorMajor = 0x777777) {
      const geom = new THREE.BufferGeometry();
      const verts = [];
      const colors = [];
      const halfW = width / 2, halfH = height / 2;
      const cMinor = new THREE.Color(colorMinor);
      const cMajor = new THREE.Color(colorMajor);

      // vertical lines (X constant)
      for (let x = -halfW; x <= halfW + 1e-6; x += step) {
        const isMajor = Math.abs(x % major) < 1e-6;
        const c = isMajor ? cMajor : cMinor;
        verts.push(x, -halfH, 0,  x, halfH, 0);
        colors.push(c.r, c.g, c.b,  c.r, c.g, c.b);
      }
      // horizontal lines (Y constant)
      for (let y = -halfH; y <= halfH + 1e-6; y += step) {
        const isMajor = Math.abs(y % major) < 1e-6;
        const c = isMajor ? cMajor : cMinor;
        verts.push(-halfW, y, 0,  halfW, y, 0);
        colors.push(c.r, c.g, c.b,  c.r, c.g, c.b);
      }

      geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const mat = new THREE.LineBasicMaterial({ vertexColors: true });
      return new THREE.LineSegments(geom, mat);
    }

    const rectGrid = makeRectGrid(worldWidth, worldHeight, gridStep, majorEvery);
    scene.add(rectGrid);

    // --- Axes to edges + labels ---
    function axisLine(start, end, color) {
      const geom = new THREE.BufferGeometry();
      const pts = new Float32Array([start.x, start.y, start.z, end.x, end.y, end.z]);
      geom.setAttribute('position', new THREE.BufferAttribute(pts, 3));
      const mat = new THREE.LineBasicMaterial({ color });
      return new THREE.Line(geom, mat);
    }

    const halfW = worldWidth/2;
    const halfH = worldHeight/2;
    const zHeight = 500;

    const xAxis = axisLine(new THREE.Vector3(0,0,0), new THREE.Vector3( halfW, 0, 0), 0xff0000);
    const yAxis = axisLine(new THREE.Vector3(0,0,0), new THREE.Vector3(0, halfH, 0), 0x00ff00);
    const zAxis = axisLine(new THREE.Vector3(0,0,0), new THREE.Vector3(0, 0, zHeight), 0x0000ff);

    scene.add(xAxis, yAxis, zAxis);

    const edgePad = 40;
    const labelX = makeTextSprite('X'); labelX.position.set( halfW+edgePad, 0, 0);
    const labelY = makeTextSprite('Y'); labelY.position.set( 0, halfH+edgePad, 0);
    const labelZ = makeTextSprite('Z'); labelZ.position.set( 0, 0, zHeight+edgePad);
    scene.add(labelX, labelY, labelZ);

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1200, 900, 1500);
    scene.add(dir);

    // --- Object store & loader ---
    const objectsByName = new Map();
    const gltfLoader = new THREE.GLTFLoader();

    function animate() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Helpers ---
    function base64ToArrayBuffer(b64) {
      const binary = atob(b64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    function rodriguesDegToQuaternion(rx, ry, rz) {
      const angleDeg = Math.hypot(rx, ry, rz);
      if (angleDeg === 0) return new THREE.Quaternion();
      const ax = rx / angleDeg, ay = ry / angleDeg, az = rz / angleDeg;
      const angleRad = angleDeg * Math.PI / 180.0;
      const q = new THREE.Quaternion();
      q.setFromAxisAngle(new THREE.Vector3(ax, ay, az), angleRad);
      return q;
    }

    function ensureVertexColors(node) {
      node.traverse(obj => {
        if (obj.isMesh) {
          const hasColors = !!obj.geometry?.getAttribute?.('color');
          if (hasColors) {
            if (Array.isArray(obj.material)) obj.material.forEach(m => m && (m.vertexColors = true));
            else if (obj.material) obj.material.vertexColors = true;
          }
        }
      });
    }

    function upsertObject(name, spec) {
      // delete
      if (spec.delete === true) {
        const prev = objectsByName.get(name);
        if (prev) {
          scene.remove(prev);
          prev.traverse(obj => {
            if (obj.isMesh) {
              obj.geometry?.dispose?.();
              const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
              mats.forEach(m => m?.dispose?.());
            }
          });
          objectsByName.delete(name);
        }
        return;
      }

      // ensure root exists
      let root = objectsByName.get(name);
      if (!root) {
        root = new THREE.Group();
        root.name = name;
        scene.add(root);
        objectsByName.set(name, root);
      }

      // meshUrl path
      if (spec.meshUrl && root.children.length === 0) {
        gltfLoader.load(
          spec.meshUrl,
          (gltf) => {
            const inst = gltf.scene || gltf.scenes[0];
            ensureVertexColors(inst);
            inst.scale.setScalar(1); // keep mm
            root.add(inst);
          },
          undefined,
          (err) => console.error("[mesh] load error", name, spec.meshUrl, err)
        );
      }

      // inline base64 GLB path
      if (spec.mesh) {
        const buffer = base64ToArrayBuffer(spec.mesh);
        while (root.children.length) {
          const ch = root.children.pop();
          ch.traverse(obj => {
            if (obj.isMesh) {
              obj.geometry?.dispose?.();
              const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
              mats.forEach(m => m?.dispose?.());
            }
          });
          root.remove(ch);
        }
        gltfLoader.parse(
          buffer,
          "",
          (gltf) => {
            const inst = gltf.scene || gltf.scenes[0];
            ensureVertexColors(inst);
            inst.scale.setScalar(1); // keep mm as-is
            root.add(inst);
          },
          (err) => console.error("GLB parse error:", err)
        );
      }

      // pose (rotation vector in degrees)
      if (Array.isArray(spec.pose) && spec.pose.length === 6) {
        const [x, y, z, rx, ry, rz] = spec.pose;
        root.position.set(x, y, z);
        root.quaternion.copy(rodriguesDegToQuaternion(rx, ry, rz));
      }

      if (typeof spec.visible === "boolean") {
        root.visible = spec.visible;
      }
    }

    // --- Socket.IO hookup ---
    const socket = io({ path: "/socket.io/" });
    socket.on("scene_update", (payload) => {
      if (!payload || typeof payload !== "object") return;
      const entries = Object.entries(payload);
      for (const [name, spec] of entries) upsertObject(name, spec || {});
    });
  </script>
</body>
</html>
