<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Live Three.js Scene (Flask + Socket.IO)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#111; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #eee; font-family: system-ui, sans-serif;
      padding: 6px 10px; background: rgba(0,0,0,0.4); border-radius: 8px; font-size: 14px;
    }
  </style>

  <!-- Three.js & helpers (non-module builds so we can use simple <script> tags) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/effects/OutlineEffect.js"></script>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
  <div id="info">Use mouse to orbit • Waiting for updates…</div>
  <script>
    // ---------- Config (tweak to taste) ----------
    const TOON = {
      bands: 4,                 // cel steps (1..8 is typical)
      edgeLineColor: 0x000000,  // EdgesGeometry overlay color
      edgeLineOpacity: 1.0,
      edgeLineWidth: 1,         // in pixels (LineBasicMaterial; note wide lines vary by platform)
      thresholdAngle: 30,       // degrees between face normals to draw an edge
      side : THREE.DoubleSide,
      outline: {
        thickness: 0.002,       // OutlineEffect thickness (~ screen-space)
        color: new THREE.Color(0x000000),
        alpha: 1.0
      }
    };

    // --- Basic Three.js scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x707070);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
    camera.position.set(1.5, 1.2, 2.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Wrap the renderer with OutlineEffect for bold outer silhouette
    const effect = new THREE.OutlineEffect(renderer, {
      defaultThickness: TOON.outline.thickness,
      defaultColor: [TOON.outline.color.r, TOON.outline.color.g, TOON.outline.color.b],
      defaultAlpha: TOON.outline.alpha,
      defaultKeepAlive: true
    });

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // size is the length of each axis line
    const axesHelper = new THREE.AxesHelper(1); // 1 unit long
    scene.add(axesHelper);

    // light
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(3, 5, 2);
    scene.add(dir);

    // Optional ground grid
    const grid = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
    scene.add(grid);

    // Store live objects by their unique name
    const objectsByName = new Map();

    // GLTF loader (we'll use .parse since we'll receive ArrayBuffer from base64)
    const gltfLoader = new THREE.GLTFLoader();

    // --- Cel gradient map (for MeshToonMaterial) ---
    function makeToonGradientTexture(bands = 4) {
      const steps = Math.max(1, Math.floor(bands));
      const data = new Uint8Array(steps);
      for (let i = 0; i < steps; i++) {
        // distribute luminance steps from dark->bright
        data[i] = Math.round((i + 0.5) * 255 / steps);
      }
      const tex = new THREE.DataTexture(data, steps, 1, THREE.LuminanceFormat);
      tex.needsUpdate = true;
      tex.magFilter = THREE.NearestFilter;
      tex.minFilter = THREE.NearestFilter;
      tex.generateMipmaps = false;
      return tex;
    }
    const toonGradient = makeToonGradientTexture(TOON.bands);

    // Apply toon material + edge lines to every mesh in a node
    function toonifyNode(node) {
      node.traverse(obj => {
        if (!obj.isMesh) return;

        const geom = obj.geometry;
        const hasColors = !!geom.getAttribute && !!geom.getAttribute('color');

        // Dispose old material(s) to avoid leaks
        const oldMats = Array.isArray(obj.material) ? obj.material : [obj.material];
        oldMats.forEach(m => m && m.dispose && m.dispose());

        // MeshToonMaterial with vertex colors as base color multiplier
        const mat = new THREE.MeshToonMaterial({
          color: 0xffffff,          // multiplied by vertex colors if present
          vertexColors: hasColors,  // use COLOR_0 when available
          gradientMap: toonGradient,
          // Optional: flatShading tightens the faceted look (try commenting out)
          flatShading: true
        });

        // Preserve alpha test if original had it (useful for cutouts)
        if (oldMats[0] && oldMats[0].alphaTest !== undefined) {
          mat.alphaTest = oldMats[0].alphaTest;
          mat.transparent = oldMats[0].transparent || mat.alphaTest > 0.0;
        }

        obj.material = mat;

        // --- Add angle-threshold edge overlay (Edged wire) ---
        // Remove a previous edge child if we re-toonify/update
        const prevEdge = obj.userData.__edgeLines;
        if (prevEdge) {
          obj.remove(prevEdge);
          prevEdge.geometry.dispose();
          prevEdge.material.dispose();
          obj.userData.__edgeLines = null;
        }

        // Build fresh edges
        const edgesGeo = new THREE.EdgesGeometry(geom, TOON.thresholdAngle);
        const edgesMat = new THREE.LineBasicMaterial({
          color: TOON.edgeLineColor,
          opacity: TOON.edgeLineOpacity,
          transparent: TOON.edgeLineOpacity < 1.0,
          linewidth: TOON.edgeLineWidth // note: wide lines aren’t supported on most platforms
        });
        const edgeLines = new THREE.LineSegments(edgesGeo, edgesMat);
        edgeLines.renderOrder = 999; // draw after mesh
        obj.add(edgeLines);
        obj.userData.__edgeLines = edgeLines;
      });
    }

    function animate() {
      controls.update();
      // Use OutlineEffect to render — gives bold silhouette outlining whole objects
      effect.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Helpers ---

    // base64 string (no data: prefix) -> ArrayBuffer
    function base64ToArrayBuffer(b64) {
      // atob works for reasonably sized payloads; for very large, consider chunking/streams
      const binary = atob(b64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    // Rodrigues vector (degrees): v = axis * angle_deg
    // Convert to quaternion. If |v|=0 -> identity
    function rodriguesDegToQuaternion(rx, ry, rz) {
      const angleDeg = Math.sqrt(rx*rx + ry*ry + rz*rz);
      if (angleDeg === 0) return new THREE.Quaternion(); // identity

      const ax = rx / angleDeg, ay = ry / angleDeg, az = rz / angleDeg;
      const angleRad = angleDeg * Math.PI / 180.0;
      const q = new THREE.Quaternion();
      q.setFromAxisAngle(new THREE.Vector3(ax, ay, az), angleRad);
      return q;
    }

    function ensureVertexColors(node) {
      // If meshes have COLOR_0 attribute but materials don't use vertex colors, enable it.
      node.traverse(obj => {
        if (obj.isMesh) {
          const hasColors = !!obj.geometry && !!obj.geometry.getAttribute && !!obj.geometry.getAttribute('color');
          if (hasColors) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => { if (m) m.vertexColors = true; });
            } else if (obj.material) {
              obj.material.vertexColors = true;
            }
          }
        }
      });
    }

    // Create or update a single object entry
    function upsertObject(name, spec) {
      // Delete?
      if (spec.delete === true) {
        const prev = objectsByName.get(name);
        if (prev) {
          scene.remove(prev);
          // dispose to free GPU memory
          prev.traverse(obj => {
            if (obj.isMesh) {
              obj.geometry?.dispose?.();
              const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
              mats.forEach(m => m?.dispose?.());
              // dispose edge overlays if present
              if (obj.userData.__edgeLines) {
                obj.userData.__edgeLines.geometry.dispose();
                obj.userData.__edgeLines.material.dispose();
                obj.userData.__edgeLines = null;
              }
            }
          });
          objectsByName.delete(name);
        }
        return;
      }

      // Either get existing root node or make a new one
      let root = objectsByName.get(name);
      if (!root) {
        root = new THREE.Group();
        root.name = name;
        scene.add(root);
        objectsByName.set(name, root);
      }

      // If new mesh data is provided, (re)load GLB into this root
      if (spec.mesh) {
        const buffer = base64ToArrayBuffer(spec.mesh);

        // Clear previous children
        while (root.children.length) {
          const ch = root.children.pop();
          ch.traverse(obj => {
            if (obj.isMesh) {
              obj.geometry?.dispose?.();
              const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
              mats.forEach(m => m?.dispose?.());
              if (obj.userData.__edgeLines) {
                obj.userData.__edgeLines.geometry.dispose();
                obj.userData.__edgeLines.material.dispose();
                obj.userData.__edgeLines = null;
              }
            }
          });
          root.remove(ch);
        }

        gltfLoader.parse(
          buffer,                       // ArrayBuffer
          "",                           // path for external resources (unused for GLB)
          (gltf) => {
            const inst = gltf.scene || gltf.scenes[0];
            // Optional: if original materials had vertex colors, they'll be honored here,
            // but we replace with toon material below.
            ensureVertexColors(inst);
            // Toonify everything (material + edge overlay)
            toonifyNode(inst);
            root.add(inst);
          },
          (err) => console.error("GLB parse error:", err)
        );
      }

      // Pose update: [x,y,z, rx,ry,rz] with Rodrigues-deg rotation
      if (Array.isArray(spec.pose) && spec.pose.length === 6) {
        const [x, y, z, rx, ry, rz] = spec.pose;
        root.position.set(x, y, z);
        root.quaternion.copy(rodriguesDegToQuaternion(rx, ry, rz));
      }

      // Visibility
      if (typeof spec.visible === "boolean") {
        root.visible = spec.visible;
      }
    }

    // --- Socket.IO hookup ---
    const socket = io();

    socket.on("connect", () => {
      document.getElementById("info").textContent = "Connected. Waiting for updates…";
    });

    socket.on("scene_update", (payload) => {
      // payload is a dict: { "objName1": { ... }, "objName2": { ... }, ... }
      if (!payload || typeof payload !== "object") return;
      for (const [name, spec] of Object.entries(payload)) {
        upsertObject(name, spec || {});
      }
    });

    socket.on("disconnect", () => {
      document.getElementById("info").textContent = "Disconnected.";
    });
  </script>
</body>
</html>
